<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width,user-scalable=no,minimum-scale=1,maximum-scale=1">
<title>AR Multi-Marker Cube</title>
	<script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/three.js/build/ar-threex.js"></script>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
<!-- 
  Example created from Lee Stemkoski: https://github.com/stemkoski
  Based on the AR.js library and examples created by Jerome Etienne: https://github.com/jeromeetienne/AR.js/
-->

<script>
var scene, camera, renderer, clock, deltaTime, totalTime;
var arToolkitSource, arToolkitContext;
var patternArray, markerRootArray, markerGroupArray;
var sceneGroup;

initialize();
animate();

function initialize() {
	scene = new THREE.Scene();
	let ambientLight = new THREE.AmbientLight( 0xcccccc, 0.5 );
	scene.add( ambientLight );
	
	camera = new THREE.Camera();
	scene.add(camera);
	
	renderer = new THREE.WebGLRenderer({
		antialias : true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	renderer.setSize( 1024, 768 );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement );

	clock = new THREE.Clock();
	deltaTime = 0;
	totalTime = 0;
	
	////////////////////////////////////////////////////////////
	// setup arToolkitSource
	////////////////////////////////////////////////////////////
	arToolkitSource = new THREEx.ArToolkitSource({
		sourceType : 'webcam',
	});

	function onResize() {
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if ( arToolkitContext.arController !== null ) {
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}	
	}
	arToolkitSource.init(function onReady(){
		onResize()
	});
	// handle resize event
	window.addEventListener('resize', function(){
		onResize()
	});
	
	////////////////////////////////////////////////////////////
	// setup arToolkitContext
	////////////////////////////////////////////////////////////	
	// create atToolkitContext
	arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: 'data/camera_para.dat',
		detectionMode: 'mono'
	});
	// copy projection matrix to camera when initialization complete
	arToolkitContext.init( function onCompleted(){
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	});

	////////////////////////////////////////////////////////////
	// setup markerRoots
	////////////////////////////////////////////////////////////
	markerRootArray  = [];
	markerGroupArray = [];
	patternArray = ["letterA", "letterB", "letterC", "letterD", "letterF", "kanji"];
	
	let rotationArray = [ new THREE.Vector3(-Math.PI/2,0,0), new THREE.Vector3(0,-Math.PI/2,Math.PI/2), new THREE.Vector3(Math.PI/2, 0, Math.PI), 
		new THREE.Vector3(-Math.PI/2,Math.PI/2,0), new THREE.Vector3(Math.PI,0,0), new THREE.Vector3(0,0,0) ];
		
	for (let i = 0; i < 6; i++) {
		let markerRoot = new THREE.Group();
		markerRootArray.push( markerRoot );
		scene.add(markerRoot);
		let markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
			type : 'pattern', patternUrl : "data/" + patternArray[i] + ".patt",
		});
	
		let markerGroup = new THREE.Group();
		markerGroupArray.push( markerGroup );
		markerGroup.position.y = -1.25/2;
		markerGroup.rotation.setFromVector3( rotationArray[i] );
		markerRoot.add( markerGroup );
	}
	
	////////////////////////////////////////////////////////////
	// setup scene
	////////////////////////////////////////////////////////////
	sceneGroup = new THREE.Group();
	// a 1x1x1 cube model with scale factor 1.25 fills up the physical cube
	sceneGroup.scale.set(1.25/2, 1.25/2, 1.25/2);
	let loader = new THREE.TextureLoader();
	
	// a simple cube
	let materialArray = [
		new THREE.MeshBasicMaterial( { map: loader.load("images/xpos.png") } ),
		new THREE.MeshBasicMaterial( { map: loader.load("images/xneg.png") } ),
		new THREE.MeshBasicMaterial( { map: loader.load("images/ypos.png") } ),
		new THREE.MeshBasicMaterial( { map: loader.load("images/yneg.png") } ),
		new THREE.MeshBasicMaterial( { map: loader.load("images/zpos.png") } ),
		new THREE.MeshBasicMaterial( { map: loader.load("images/zneg.png") } ),
	];
	// let mesh = new THREE.Mesh( new THREE.CubeGeometry(2,2,2), materialArray ); // deprecated
	let mesh = new THREE.Mesh( new THREE.BoxGeometry(2,2,2), materialArray );
	mesh.position.y = 1;
	mesh.position.x = 1;
	mesh.position.z = 1;
	sceneGroup.add( mesh );
}
	
function update() {
	// update artoolkit on every frame
	if ( arToolkitSource.ready !== false )
		arToolkitContext.update( arToolkitSource.domElement );
	for (let i = 0; i < 6; i++) {
		if ( markerRootArray[i].visible ) {
			markerGroupArray[i].add( sceneGroup );
			console.log("visible: " + patternArray[i]);
			break;
		}
	}
}

function render() {
	renderer.render( scene, camera );
}
function animate() {
	requestAnimationFrame(animate);
	deltaTime = clock.getDelta();
	totalTime += deltaTime;
	update();
	render();
}
</script>

</body>
</html>
