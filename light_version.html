<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width,user-scalable=no,minimum-scale=1,maximum-scale=1">
<title>AR Multi-Marker Cube</title>
<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js'></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/three.js/build/ar-threex.js"></script>
</head>
<body style='margin:0;overflow:hidden'>
<script>
let scene,camera,renderer,clock=new THREE.Clock(),arToolkitSource,arToolkitContext;
let markerRoots=[],markerControls=[];

const markerUrls=[
'data/kanji.patt',
'data/letterA.patt',
'data/letterB.patt',
'data/letterC.patt',
'data/letterD.patt',
'data/letterF.patt'
];

const faceColors=[0x0000ff,0xff0000,0x00ff00,0xffff00,0xff00ff,0x00ffff];
const facePositions=[
[0,0,0.5],[0,0,-0.5],[0.5,0,0],[-0.5,0,0],[0,0.5,0],[0,-0.5,0]
];
const faceRotations=[
[0,0,0],[0,Math.PI,0],[0,Math.PI/2,0],[0,-Math.PI/2,0],[-Math.PI/2,0,0],[Math.PI/2,0,0]
];

function init(){
scene=new THREE.Scene();
camera=new THREE.Camera();
scene.add(camera);

renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
renderer.setClearColor(new THREE.Color('lightgrey'),0);
renderer.setSize(640,480);
renderer.domElement.style.position='absolute';
renderer.domElement.style.top='0px';
renderer.domElement.style.left='0px';
document.body.appendChild(renderer.domElement);

arToolkitSource=new THREEx.ArToolkitSource({sourceType:'webcam'});
arToolkitSource.init(()=>{onResize()});

arToolkitContext=new THREEx.ArToolkitContext({
cameraParametersUrl:'data/camera_para.dat',
detectionMode:'mono'
});
arToolkitContext.init(()=>{camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix())});

for(let i=0;i<6;i++){
let root=new THREE.Group();
scene.add(root);
markerRoots.push(root);

let ctrl=new THREEx.ArMarkerControls(arToolkitContext,root,{
type:'pattern',
patternUrl:markerUrls[i]
});
markerControls.push(ctrl);

let geo=new THREE.PlaneGeometry(1,1);
let mat=new THREE.MeshBasicMaterial({color:faceColors[i],transparent:true,opacity:0.7,side:THREE.DoubleSide});
let mesh=new THREE.Mesh(geo,mat);
mesh.position.set(...facePositions[i]);
mesh.rotation.set(...faceRotations[i]);
root.add(mesh);

let edgeGeo=new THREE.EdgesGeometry(geo);
let edgeMat=new THREE.LineBasicMaterial({color:0x000000,linewidth:2});
let edges=new THREE.LineSegments(edgeGeo,edgeMat);
edges.position.copy(mesh.position);
edges.rotation.copy(mesh.rotation);
root.add(edges);
}

window.addEventListener('resize',onResize);
animate();
}

function onResize(){
arToolkitSource.onResizeElement();
arToolkitSource.copyElementSizeTo(renderer.domElement);
if(arToolkitContext.arController)arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas);
}

function update(){
if(arToolkitSource.ready)arToolkitContext.update(arToolkitSource.domElement);
}

function animate(){
requestAnimationFrame(animate);
clock.getDelta();
update();
renderer.render(scene,camera);
}

init();
</script>
</body>
</html>
